++++++++++++++++++++++++++++++++++++++++++++++++
名称|说明|备注
-|-|-|-|-
public|可以被任何类访问|
protected|可以被同一包中所有的类访问，可以被所有子类访问|子类没有在同一包也可以访问
private|只能够被当前类的方法访问|
无访问修饰符|可以被同一包类所有类访问|如果没有在同一个包中，也不能访问

++++++++++++++++++++++++++++++++++++++++++++++
<br><br>

ArrayList和Vector类都是基于数组实现的List类。ArrayList和Vector的显著区别是：ArrayList类是线程不安全的，二Vector是线程安全的，所以Vector性能比ArrayList性能稍低。此外Vector类还提供了一个Stack子类，用于模拟“栈”的数据结构。

++++++++++++++++++++++++++++++++++++++++++++++

1、Java中用补码形式表示
2、第一位正负位，1表示负，0表示正。
3、原码：一个数的二进制表示。
                 3的原码00000011   -3的 原码 10000011
4、反码：负数原码按位取反（符号位不变）。正数原码本身。
                3的反码00000011   -3的反码11111100
5、补码：正数是原码本身。负数反码加1。
                 3的补码是00000011  -3的补码是11111101

int占4个字节，32位
byte占1个字节，8位
所以强转时会截断。前24位

在内存中表示形式（ 注意java中是以补码表示一个数，所以表示形式是补码，不是原码！ ）：
int a = 3      &nbsp  &nbsp  &nbsp 00000000  00000000  00000000 00000011 （强转byte时前面24个0被截断）
byte b = 3   &nbsp  &nbsp  &nbsp   00000011
int a = -3     &nbsp  &nbsp  &nbsp  11111111  11111111   11111111   11111101 （强转byte时前面24个1被截断）
byte b = -3   &nbsp  &nbsp  &nbsp 11111101

已知负数的补码，求负数：
补码-1=反码，反码按位取反=该负数绝对值
已知负数，求负数的补码：
1、负数原码除了符号位，按位取反（不含符号位），加1。
2、负数绝对值的补码（也就是原码），按位取反（含符号位），加1
例子：
java int 128转为byte，值：
128为正数，补码为10000000（前面24个0省略），变成byte，只剩下10000000（byte为1个字节），因为开头是1，所以为负数。即1个负数的补码是10000000。反码是01111111，原码是1000000。是128.因为是负数，所以是-128。

+++++++++++++++++++++++++++++++++++++++<br><br><br>
在接口里面的变量默认都是public static final的，相当于全局常量，可以直接省略	修饰符，实现类可以直接访问接口中的变量。
如下题：
```
public class A implements B{
public static void main（String args[]）{
		int i;
		A a1=new  A（）;
		i =a1.k;
		System.out.println（“i=”+i）;
	}
}
interface B
{
	int k=10；
}
```
代码会输出i=10
+++++++++++++++++++++++++++++++++++++++++++++++
<br><br><br>

题目
```
class Person {
    String name = "No name";
    public Person(String nm) {
        name = nm;
    }
}
class Employee extends Person {
    String empID = "0000";
    public Employee(String id) {
        empID = id;
    }
}
public class Test {
    public static void main(String args[]) {
        Employee e = new Employee("123");
        System.out.println(e.empID);
    }
}
```
此段代码将编译报错
原因是子类构造方法总是先调用父类的构造方法，如果子类的构造方法没有明显的指明使用父类的哪个构造方法，子类就调用父类不带参数的构造方法。上面代码中父类没有无参数的构造方法，所依子类要在自己的构造函数中显示的调用父类的构造函数，可以在子类构造函数中加上super(id)；
